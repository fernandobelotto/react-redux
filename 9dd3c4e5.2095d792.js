(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{110:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return l}));var o=n(2),a=n(6),r=(n(0),n(147)),c={id:"static-typing",title:"Static Typing",hide_title:!0,sidebar_label:"Static Typing"},i={unversionedId:"using-react-redux/static-typing",id:"version-7.1/using-react-redux/static-typing",isDocsHomePage:!1,title:"Static Typing",description:"Static Typing",source:"@site/versioned_docs\\version-7.1\\using-react-redux\\static-types.md",slug:"/using-react-redux/static-typing",permalink:"/react-redux/7.1/using-react-redux/static-typing",version:"7.1",sidebar_label:"Static Typing",sidebar:"version-7.1/docs",previous:{title:"Accessing the Store",permalink:"/react-redux/7.1/using-react-redux/accessing-store"},next:{title:"Connect",permalink:"/react-redux/7.1/api/connect"}},p=[{value:"TypeScript",id:"typescript",children:[{value:"Defining the Root State Type",id:"defining-the-root-state-type",children:[]},{value:"Typing the <code>useSelector</code> hook",id:"typing-the-useselector-hook",children:[]},{value:"Typing the <code>useDispatch</code> hook",id:"typing-the-usedispatch-hook",children:[]},{value:"Typing the <code>connect</code> higher order component",id:"typing-the-connect-higher-order-component",children:[]},{value:"Recommendations",id:"recommendations",children:[]}]},{value:"Resources",id:"resources",children:[]}],s={rightToc:p};function l(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"static-typing"},"Static Typing"),Object(r.b)("p",null,"React-Redux is currently written in plain JavaScript. However, it works well with static type systems such as TypeScript and Flow."),Object(r.b)("h2",{id:"typescript"},"TypeScript"),Object(r.b)("p",null,"React-Redux doesn't ship with its own type definitions. If you are using Typescript you should install the ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://npm.im/@types/react-redux"}),Object(r.b)("inlineCode",{parentName:"a"},"@types/react-redux")," type definitions")," from npm. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components."),Object(r.b)("h3",{id:"defining-the-root-state-type"},"Defining the Root State Type"),Object(r.b)("p",null,"Both ",Object(r.b)("inlineCode",{parentName:"p"},"mapState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"useSelector")," depend on declaring the type of the complete Redux store state value. While this type could be written by hand, the easiest way to define it is to have TypeScript infer it based on what your root reducer function returns. This way, the type is automatically updated as the reducer functions are modified."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"// rootReducer.ts\nexport const rootReducer = combineReducers({\n  posts: postsReducer,\n  comments: commentsReducer,\n  users: usersReducer\n})\n\nexport type RootState = ReturnType<typeof rootReducer>\n// {posts: PostsState, comments: CommentsState, users: UsersState}\n")),Object(r.b)("h3",{id:"typing-the-useselector-hook"},"Typing the ",Object(r.b)("inlineCode",{parentName:"h3"},"useSelector")," hook"),Object(r.b)("p",null,"When writing selector functions for use with ",Object(r.b)("inlineCode",{parentName:"p"},"useSelector"),", you should explicitly define the type of the ",Object(r.b)("inlineCode",{parentName:"p"},"state")," parameter. TS should be able to then infer the return type of the selector, which will be reused as the return type of the ",Object(r.b)("inlineCode",{parentName:"p"},"useSelector")," hook:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"interface RootState {\n  isOn: boolean\n}\n\n// TS infers type: (state: RootState) => boolean\nconst selectIsOn = (state: RootState) => state.isOn\n\n// TS infers `isOn` is boolean\nconst isOn = useSelector(selectIsOn)\n")),Object(r.b)("p",null,"If you want to avoid repeating the ",Object(r.b)("inlineCode",{parentName:"p"},"state")," type declaration, you can define a typed ",Object(r.b)("inlineCode",{parentName:"p"},"useSelector")," hook using a helper type exported by ",Object(r.b)("inlineCode",{parentName:"p"},"@types/react-redux"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"// reducer.ts\nimport { useSelector, TypedUseSelectorHook } from 'react-redux'\n\ninterface RootState {\n  isOn: boolean\n}\n\nexport const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector\n\n// my-component.tsx\nimport { useTypedSelector } from './reducer.ts'\n\nconst isOn = useTypedSelector(state => state.isOn)\n")),Object(r.b)("h3",{id:"typing-the-usedispatch-hook"},"Typing the ",Object(r.b)("inlineCode",{parentName:"h3"},"useDispatch")," hook"),Object(r.b)("p",null,"By default, the return value of ",Object(r.b)("inlineCode",{parentName:"p"},"useDispatch")," is the standard ",Object(r.b)("inlineCode",{parentName:"p"},"Dispatch")," type defined by the Redux core types, so no declarations are needed:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"const dispatch = useDispatch()\n")),Object(r.b)("p",null,"If you have a customized version of the ",Object(r.b)("inlineCode",{parentName:"p"},"Dispatch")," type, you may use that type explicitly:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"// store.ts\nexport type AppDispatch = typeof store.dispatch\n\n// MyComponent.tsx\nconst dispatch: AppDispatch = useDispatch()\n")),Object(r.b)("h3",{id:"typing-the-connect-higher-order-component"},"Typing the ",Object(r.b)("inlineCode",{parentName:"h3"},"connect")," higher order component"),Object(r.b)("h4",{id:"manually-typing-connect"},"Manually Typing ",Object(r.b)("inlineCode",{parentName:"h4"},"connect")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"connect")," higher-order component is somewhat complex to type, because there are 3 sources of props: ",Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps"),", ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatchToProps"),", and props passed in from the parent component. Here's a full example of what it looks like to do that manually."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"import { connect } from 'react-redux'\n\ninterface StateProps {\n  isOn: boolean\n}\n\ninterface DispatchProps {\n  toggleOn: () => void\n}\n\ninterface OwnProps {\n  backgroundColor: string\n}\n\ntype Props = StateProps & DispatchProps & OwnProps\n\nconst mapState = (state: RootState) => ({\n  isOn: state.isOn\n})\n\nconst mapDispatch = {\n  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })\n}\n\nconst MyComponent = (props: Props) => (\n  <div style={{ backgroundColor: props.backgroundColor }}>\n    <button onClick={props.toggleOn}>\n      Toggle is {props.isOn ? 'ON' : 'OFF'}\n    </button>\n  </div>\n)\n\n// Typical usage: `connect` is called after the component is defined\nexport default connect<StateProps, DispatchProps, OwnProps>(\n  mapState,\n  mapDispatch\n)(MyComponent)\n")),Object(r.b)("p",null,"It is also possible to shorten this somewhat, by inferring the types of ",Object(r.b)("inlineCode",{parentName:"p"},"mapState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatch"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"const mapState = (state: RootState) => ({\n  isOn: state.isOn\n})\n\nconst mapDispatch = {\n  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })\n}\n\ntype StateProps = ReturnType<typeof mapState>\ntype DispatchProps = typeof mapDispatch\n\ntype Props = StateProps & DispatchProps & OwnProps\n")),Object(r.b)("p",null,"However, inferring the type of ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatch")," this way will break if it is defined as an object and also refers to thunks."),Object(r.b)("h4",{id:"inferring-the-connected-props-automatically"},"Inferring The Connected Props Automatically"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"connect")," consists of two functions that are called sequentially. The first function accepts ",Object(r.b)("inlineCode",{parentName:"p"},"mapState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatch")," as arguments, and returns a second function. The second function accepts the component to be wrapped, and returns a new wrapper component that passes down the props from ",Object(r.b)("inlineCode",{parentName:"p"},"mapState")," and ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatch"),". Normally, both functions are called together, like ",Object(r.b)("inlineCode",{parentName:"p"},"connect(mapState, mapDispatch)(MyComponent)"),"."),Object(r.b)("p",null,"As of v7.1.2, the ",Object(r.b)("inlineCode",{parentName:"p"},"@types/react-redux")," package exposes a helper type, ",Object(r.b)("inlineCode",{parentName:"p"},"ConnectedProps"),", that can extract the return types of ",Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps")," and ",Object(r.b)("inlineCode",{parentName:"p"},"mapDispatchToProps")," from the first function. This means that if you split the ",Object(r.b)("inlineCode",{parentName:"p"},"connect"),' call into two steps, all of the "props from Redux" can be inferred automatically without having to write them by hand. While this approach may feel unusual if you\'ve been using React-Redux for a while, it does simplify the type declarations considerably.'),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-ts"}),"import { connect, ConnectedProps } from 'react-redux'\n\ninterface RootState {\n  isOn: boolean\n}\n\nconst mapState = (state: RootState) => ({\n  isOn: state.isOn\n})\n\nconst mapDispatch = {\n  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })\n}\n\nconst connector = connect(\n  mapState,\n  mapDispatch\n)\n\n// The inferred type will look like:\n// {isOn: boolean, toggleOn: () => void}\ntype PropsFromRedux = ConnectedProps<typeof connector>\n")),Object(r.b)("p",null,"The return type of ",Object(r.b)("inlineCode",{parentName:"p"},"ConnectedProps")," can then be used to type your props object."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"interface Props extends PropsFromRedux {\n  backgroundColor: string\n}\n\nconst MyComponent = (props: Props) => (\n  <div style={{ backgroundColor: props.backgroundColor }}>\n    <button onClick={props.toggleOn}>\n      Toggle is {props.isOn ? 'ON' : 'OFF'}\n    </button>\n  </div>\n)\n\nexport default connector(MyComponent)\n")),Object(r.b)("p",null,"Because types can be defined in any order, you can still declare your component before declaring the connector if you want."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-tsx"}),"// alternately, declare `type Props = PropsFromRedux & {backgroundColor: string}`\ninterface Props extends PropsFromRedux {\n  backgroundColor: string;\n}\n\nconst MyComponent = (props: Props) => /* same as above */\n\nconst connector = connect(/* same as above*/)\n\ntype PropsFromRedux = ConnectedProps<typeof connector>\n\nexport default connector(MyComponent)\n")),Object(r.b)("h3",{id:"recommendations"},"Recommendations"),Object(r.b)("p",null,"The hooks API is generally simpler to use with static types. ",Object(r.b)("strong",{parentName:"p"},"If you're looking for the easiest solution for using static types with React-Redux, use the hooks API.")),Object(r.b)("p",null,"If you're using ",Object(r.b)("inlineCode",{parentName:"p"},"connect"),", ",Object(r.b)("strong",{parentName:"p"},"we recommend using the ",Object(r.b)("inlineCode",{parentName:"strong"},"ConnectedProps<T>")," approach for inferring the props from Redux"),", as that requires the fewest explicit type declarations."),Object(r.b)("h2",{id:"resources"},"Resources"),Object(r.b)("p",null,"For additional information, see these additional resources:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://redux.js.org/recipes/usage-with-typescript"}),"Redux docs: Usage with TypeScript"),": Examples of how to declare types for actions, reducers, and the store"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://redux-toolkit.js.org/tutorials/advanced-tutorial"}),"Redux Toolkit docs: Advanced Tutorial"),": shows how to use RTK and the React-Redux hooks API with TypeScript"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://github.com/typescript-cheatsheets/react-typescript-cheatsheet"}),"React+TypeScript Cheatsheet"),": a comprehensive guide to using React with TypeScript"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(o.a)({parentName:"li"},{href:"https://github.com/piotrwitek/react-redux-typescript-guide"}),"React + Redux in TypeScript Guide"),": extensive information on patterns for using React and Redux with TypeScript")))}l.isMDXComponent=!0},147:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),l=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),u=l(n),b=o,h=u["".concat(c,".").concat(b)]||u[b]||d[b]||r;return n?a.a.createElement(h,i(i({ref:t},s),{},{components:n})):a.a.createElement(h,i({ref:t},s))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,c=new Array(r);c[0]=b;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,c[1]=i;for(var s=2;s<r;s++)c[s]=n[s];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);